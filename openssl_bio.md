## openssl 
> 参考手册 
``` 
http://docs.huihoo.com/doxygen/openssl/1.0.1c/index.html 
http://www.openssl.org/docs/crypto/crypto.html
http://www.openssl.org/docs/ssl/ssl.html
``` 
> 资源下载  http://www.openssl.org/source/old/1.0.1/openssl-1.0.1l.tar.gz  
> 编译安装 http://www.cnblogs.com/274914765qq/p/4548980.html  
 

## openssl作用  
  OpenSSL是一个功能丰富且自包含的开源安全工具箱。它提供的主要功能有：SSL协议实现(包括SSLv2、SSLv3和TLSv1)、大量软算法(对称/非对称/摘要)、大数运算、非对称算法密钥生成、ASN.1编解码库、证书请求(PKCS10)编解码、数字证书编解码、CRL编解码、OCSP协议、数字证书验证、PKCS7标准实现和PKCS12个人数字证书格式实现等功能。
  OpenSSL采用C语言作为开发语言，这使得它具有优秀的跨平台性能。OpenSSL支持Linux、UNIX、windows、Mac等平台。OpenSSL目前最新的版本是openssl-1.0.0e.
  
## 编程实例  
堆栈、hash链表、内存管理、动态模块加载与调用、各种BIO、配置文件解析、证书申请与撤销、等
> http://www.cnblogs.com/274914765qq/p/4613007.html
  
##  SSL与TCP的区别 （select下）
  SSL实现必须读取整条记录，哪怕select返回了一个字节可读，那么ssl也要读取整个记录，这种基于记录的读写方式就是为了正确的加密个解密。因此如果用select模型的话可能会出现一些莫名其妙的问题，事实上也正是ssl消息需要加密解密从而需要整个消息整个消息读写才使得ssl协议的行为和tcp的有了少有的不一致。
  tcp的特点是流式传输，流式的特点就是没有消息边界，按字节读取，一个连接就是一个流，需要应用程序自己去划分自己的数据，举个例子就是一端写入x字节，对端可能读出y字节，具体多少要看网络状况和窗口情况，tcp在这一点上是相当复杂的，应用程序的发送只是简单的将数据放入tcp的发送缓冲区，而接收只是简单的从接收缓冲区中取回数据，反观udp就不是这样子，udp是基于数据报的，就是说不能分段，一端写入多少另一端就读出多少，当然也可能永远收不到，也可能乱序等等。现在看看ssl，它看起来好像是结合了tcp和udp的特点，它是有连接的，必须可靠传输并且按照顺序收发，但是却不是流式的，每次调用SSL_read必须读入一个ssl记录，一个ssl记录有一个固定大小的头部(5字节)，该头部指示了消息类型，ssl版本号以及消息长度，首先需要读出一个ssl消息头部，接下来就要在该头部的消息长度字段的指导下进行消息体的读取，而且必须读取完整个完整消息之后才能返回成功，否则均返回失败，并且什么都不做，ssl读操作中，带有头的消息是read的最小单位。
  通过SSL_pending可以判断是否有消息数据还在缓冲区或者还没有到缓冲区，它实际上返回的就是消息的长度，因此如果使用select调用的话，很有可能select检测到的可读情况仅仅只有tcp送来的很少的数据量，远远不够ssl需要的数据量，那么只要SSL_pending返回非0，那么就需要循环调用SSL_read继续读取，否则你会认为这是一个莫名其妙的错误。select返回后，也可以使用do{}while(1)来读取自己的数据。
